#pragma once

#include <boost/json.hpp>
#include <memory>

#include "TypeTemplateValue.hpp"
#include "TypeTemplateContext.hpp"
#include "TypeTemplateParameter.hpp"
#include "TypeTemplateError.hpp"

namespace nejlika
{

/**
 * @brief A scope for a type template, used when querying values.
 */
class TypeTemplateScope : public std::enable_shared_from_this<TypeTemplateScope>
{
friend class TypeTemplateContext;

public:
    /**
     * @brief Construct a new TypeTemplateScope object.
     * 
     * @param root The root context.
     * @param rule The rule (parameter) of the value. Nullable.
     * @param parent The parent scope. Nullable.
     * @param parameters The parameters passed to the scope.
     * @param value The JSON value of the scope.
     */
    TypeTemplateScope(
        const std::shared_ptr<TypeTemplateContext>& root,
        const std::shared_ptr<TypeTemplateParameter>& rule,
        const std::shared_ptr<TypeTemplateScope>& parent,
        const std::unordered_map<std::string, TypeTemplateValue>& parameters,
        const boost::json::object& value
    );

    /**
     * @brief Construct a new TypeTemplateScope object.
     * 
     * @param other The other scope to copy. 
     */
    TypeTemplateScope(const TypeTemplateScope& other);

    /**
     * @brief Get the root context.
     * 
     * @return The root context.
     */
    const std::shared_ptr<TypeTemplateContext>& GetRoot() const;

    /**
     * @brief Get the nejlika context
     * 
     * @return The nejlika context.
     */
    nejlika::Context& GetContext() const;

    /**
     * @brief Get the rule (parameter) of the value.
     * 
     * @return The rule (parameter) of the value.
     */
    const std::shared_ptr<TypeTemplateParameter>& GetRule() const;

    /**
     * @brief Get the parent scope.
     * 
     * @return The parent scope.
     */
    const std::shared_ptr<TypeTemplateScope>& GetParent() const;

    /**
     * @brief Get the parameters passed to the scope.
     * 
     * @return The parameters passed to the scope.
     */
    const std::unordered_map<std::string, TypeTemplateValue>& GetParameters() const;

    /**
     * @brief Resolve the parameters passed to the scope.
     * 
     * @return The resolved parameters.
     */
    std::unordered_map<std::string, TypeTemplateValue> ResolveParameters();

    /**
     * @brief Resolve the type arguments of a key.
     * 
     * @param key The key to a child parameter.
     * @return The resolved type arguments.
     */
    std::unordered_map<std::string, TypeTemplateValue> ResolveTypeArguments(const std::string& key);
    
    /**
     * @brief Get the JSON value of the scope.
     * 
     * @return The value of the scope.
     */
    const boost::json::object& GetValue() const;

    /**
     * @brief Find a value in the scope.
     * 
     * @param value The value to find.
     * @param cascade Whether to start the application of child type instances.
     * @return The found value.
     */
    boost::json::value FindValue(const TypeTemplateValue& value, TypeTemplateQueryOptions options);

    /**
     * @brief Retrieve errors generated by nested scopes.
     * 
     * @note Will be removed sometime in the future in favor of a more robust error handling system.
     */
    static std::vector<TypeTemplateError> FetchAndClearNestedErrors();

private:
    boost::json::value InternalFindValue(std::vector<std::string> parts, TypeTemplateQueryOptions options);

    boost::json::value ProcessObject(
        const boost::json::object& value,
        std::vector<std::string> parts,
        const std::shared_ptr<TypeTemplateParameter>& rule,
        TypeTemplateQueryOptions options
    );

    boost::json::value ProcessValue(
        const boost::json::value& value,
        std::vector<std::string> parts,
        const std::shared_ptr<TypeTemplateParameter>& rule,
        TypeTemplateQueryOptions options
    );
    
    boost::json::value ProcessResource(
        const boost::json::value& value,
        std::vector<std::string> parts,
        const std::shared_ptr<TypeTemplateParameter>& rule,
        TypeTemplateQueryOptions options
    );

    std::shared_ptr<TypeTemplateContext> m_Root;
    
    std::shared_ptr<TypeTemplateParameter> m_Rule;

    std::shared_ptr<TypeTemplateScope> m_Parent;

    std::unordered_map<std::string, TypeTemplateValue> m_Parameters;

    boost::json::object m_Value;
};

}